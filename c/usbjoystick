
/*

USBJoystick - a RISC OS USB HID Joystick driver

Based on NetBSD USB joystick driver in X-MAME by Krister Walfridsson <cato@df.lth.se> and Dieter Baron <dillo@giga.or.at>
Uses some NetBSD USB HID parsing functions (see headers in data/descr/parse C files)
Uses a FreeBSD USB HID report descriptor for XBOX360 controller (see usbrdesc header file)
Inspiration taken from EtherUSB by James Peacock (Copyright (C) 2012, James Peacock)
RISC OS specific USB code taken from Colin Granville's USBDescriptors (Copyright (c) 2015 Colin Granville. All rights reserved.)
C function to interface to Reporter is from Steve Fryatt's online series

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

*/

// C library
#include "swis.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "Global/NewErrors.h"

// OSLib
#include "oslib/os.h"
#include "oslib/osfind.h"
#include "oslib/osgbpb.h"
#include "oslib/osbyte.h"
#include "oslib/devicefs.h"
#include "oslib/resourcefs.h"

// our debugging utility
#include "debugrep.h"

// our usb service defs
#include "usbservice.h"

// include our CMHG header
#include "usbjoystickHdr.h"

// include our header
#include "usbjoystick.h"

// resourcefs
extern void *Resources(void);

// silence compiler warnings about unused parameters
#define IGNORE(x) do { (void)(x); } while(0)

// Vector readability
#define VECTOR_PASSON 1
#define VECTOR_CLAIM 0




// Module state

extern void* g_module_pw = NULL;



// Module errors
// This will be improved so we internationalise them

extern _kernel_oserror err_syntax = {
  ErrorNumber_Syntax,
  Module_Title ": Syntax error"
};

extern _kernel_oserror err_badnoparms = {
  ErrorNumber_BadNoParms,
  "Bad parameters"
};

extern _kernel_oserror err_toomanyparms = {
  ErrorNumber_TooManyParms,
  "Too many parameters"
};

extern _kernel_oserror err_nosuchswi = {
  ErrorNumber_NoSuchSWI,
  "No such SWI"     // ErrorString_ModuleBadSWI
};

extern _kernel_oserror err_modulebadswi = {
  ErrorNumber_ModuleBadSWI,
  "SWI value out of range for module " Module_Title
};

extern _kernel_oserror err_badjoy = {
  ErrorBase_Joystick + 1,
  "Bad joystick number"
};

extern _kernel_oserror err_nousb = {
  ErrorBase_Joystick + 2,
  Module_Title " requires USBDriver"
};

extern _kernel_oserror err_joynotactive = {
  ErrorBase_Joystick + 3,
  "Joystick not active"
};

extern _kernel_oserror err_joynotopen = {
  ErrorBase_Joystick + 4,
  "Joystick not open"
};





// Joystick data
struct joydata_struct joy_data[JOY_MAX];
struct adc_data_struct adc_data;
struct adc_map_struct adc_map;

// which joystick are we currently setting up?
unsigned int joy_index = 0;

// supported usb hid axes codes (not including HAT or DPAD)
// also note mapping to our own type codes
static const unsigned int supported_axes_usage[] = {
  [HUG_X] = AXIS_X,
  [HUG_Y] = AXIS_Y,
  [HUG_Z] = AXIS_Z,
  [HUG_RX] = AXIS_RX,
  [HUG_RY] = AXIS_RY,
  [HUG_RZ] = AXIS_RZ,
  [HUG_SLIDER] = AXIS_SLIDER,
};

static const char *axes_names[] = {
  [AXIS_HATX] = "HATX",
  [AXIS_HATY] = "HATY",
  [AXIS_DPADX] = "DPADX",
  [AXIS_DPADY] = "DPADY",
  [AXIS_X] = "X",
  [AXIS_Y] = "Y",
  [AXIS_Z] = "Z",
  [AXIS_RX] = "RX",
  [AXIS_RY] = "RY",
  [AXIS_RZ] = "RZ",
  [AXIS_SLIDER] = "S",
};

// todo: can we get away with assuming protocol==0 for standard HID devices?  keyboard is 2
static const struct joy_device_struct joy_devices[] = {
  { 0xFF, 0x5D,   1, 0x45E, 0x028E, "XBOX360 wired controller"         , JOY_TYPE_XBOX360  , (void*)&uhid_xb360gp_report_descr, sizeof(uhid_xb360gp_report_descr), 0, { 0x01, 0x03, 0x00 }                                                      ,  3, { AXIS_Y, AXIS_RY }, 2, 0 },
  { 0xFF, 0x5D, 129, 0x45E, 0x0719, "XBOX360 wireless controller"      , JOY_TYPE_XBOX360WL, (void*)&uhid_xb360gp_report_descr, sizeof(uhid_xb360gp_report_descr), 4, { 0x00, 0x00, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 12, { AXIS_Y, AXIS_RY }, 2, &xbox360wireless_data_validator },
  { 0x03, 0x00,   0,     0,     0 , "Standard HID controller (no boot)", JOY_TYPE_STANDARD ,                                 0,                                 0, 0, { 0x00 }                                                                  ,  0, { 0 }              , 0, 0 },
  { 0x03, 0x01,   0,     0,     0 , "Standard HID controller (boot)"   , JOY_TYPE_STANDARD ,                                 0,                                 0, 0, { 0x00 }                                                                  ,  0, { 0 }              , 0, 0 }
};

unsigned int joy_devices_count = sizeof(joy_devices)/sizeof(joy_devices[0]);







osbool emulate_acorn_on = TRUE;
osbool emulate_serial_port_on = TRUE;
osbool emulate_joy_on = TRUE;
osbool emulate_adc_on = TRUE;
osbool upcall_claimed = FALSE;
osbool ukswiv_claimed = FALSE;
osbool bytev_claimed = FALSE;





osbool xbox360wireless_data_validator(char *d)
{
  return (osbool)(d[0] == 0 && d[1] == 1);
}





_kernel_oserror *module_initialise(const char *cmd_tail, int podule_base, void *pw)
{
  os_error *error;

  IGNORE(cmd_tail);
  IGNORE(podule_base);

  g_module_pw = pw;

  // clean up joysticks data structure
  clean_joystick_data();

  // we must have USB
  // num_from_string will give 'swi not known', so swap this for our own error
  int usbdriver_version = 0;
  error = xos_swi_number_from_string("USBDriver_Version", &usbdriver_version);
  if (error) error = (os_error*) &err_nousb;

  // claim upcall vector for acting on usb data received
  if (!error) {
    error = xos_claim(UpCallV, &upcallv_hook, pw);
    if (!error) upcall_claimed = TRUE;
  }

  // claim ukswi vector for serial port api cmpatibility
  if (!error) {
    error = xos_claim(UKSWIV, (asm_routine)ukswiv_pre_hook, pw);
    if (!error) ukswiv_claimed = TRUE;
  }

  // claim byte vector for emulating Acorn I/O podule ADC
  if (!error) {
    error = xos_claim(ByteV, &bytev_hook, pw);
    if (!error) bytev_claimed = TRUE;
  }

  // register resources
  #ifndef ROM_MODULE
  if (!error)
    error = xresourcefs_register_files((resourcefs_file_list *) Resources());
  #else
  /* In ROM builds, all resource files live in the Messages module instead */
  #endif

  // build a list of connected joysticks
  // each usb device will be queried to check for suitability
  if (!error) {
    debug_printf("USBJoystick: scanning USB devices...\n");
    error = (os_error *) usb_scan_devices(&joy_check_device, NULL);
  }

  /*
    TODO!!!!!!
  if (!error)
    error = free memory from scan-devices
  */

  return (_kernel_oserror *) error;
}





_kernel_oserror *module_swi(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);

  switch(swi_offset)
  {
    case MODULE_SWI(Joystick_Read):
    {
      if (emulate_acorn_on)
        return swi_joystick_read(r);
      else
        return &err_nosuchswi;
      break;
    }

    case MODULE_SWI(Joystick_CalibrateTopRight):
    case MODULE_SWI(Joystick_CalibrateBottomLeft):
    {
      if (emulate_acorn_on)
        return NULL;
      else
        return &err_nosuchswi;
      break;
    }

    case MODULE_SWI(Joystick_Status):
    {
      if (emulate_serial_port_on)
        return swi_joystick_status(r);
      else
        return &err_nosuchswi;
      break;
    }
  }

  // SWI value out of range for module USBJoystick
  return &err_modulebadswi;
}





void open_joystick(unsigned int i)
{
  if (joy_data[i].in_use == FALSE)
    return;

  // open the usb data stream for reading
  os_error* error = xosfind_openinw(osfind_NO_PATH | osfind_ERROR_IF_ABSENT, joy_data[i].usb_path, NULL, &(joy_data[i].fp));

  if (error)
  {
    debug_printf("Cannot open fp %u on %s: %s\n", joy_data[i].fp, joy_data[i].usb_path, error->errmess);
    joy_data[i].fp = 0;
  }
  else if (joy_data[i].fp == 0) {
    debug_printf("Cannot open (fp is 0) on %s\n", joy_data[i].usb_path);
  }
  else
  {
    // find out the buffer handle and devicefs handle
    error = (os_error*) usb_get_device_handle((usb_device_t*)joy_data[i].device_name, joy_data[i].fp, &(joy_data[i].buffer_handle), &(joy_data[i].devicefs_handle));
    if (error) {
      debug_printf("Cannot get device/buffer handles: %s\n", error->errmess);
    }
    else {
      // get the internal buffer info
      error = xbuffer_internal_info(joy_data[i].buffer_handle, &(joy_data[i].buffer_internal_id), &(joy_data[i].buffer_service_routine), &(joy_data[i].buffer_workspace));
      if (error) {
        debug_printf("Cannot get buffer internal info: %s\n", error->errmess);
      }
      else {
        joy_data[i].open = TRUE;
        auto_map(i);
      }
    }
  }
}





void auto_map(unsigned int i)
{
  if (joy_data[i].in_use == FALSE || joy_data[i].open == FALSE)
    return;

  // 8-bit axes mapping
  osbool mapped8 = find_and_map_x_y_8(i, AXIS_DPADX, AXIS_DPADY);

  if (!mapped8)
    mapped8 = find_and_map_x_y_8(i, AXIS_HATX, AXIS_HATY);

  if (!mapped8)
    mapped8 = find_and_map_x_y_8(i, AXIS_X, AXIS_Y);

  // 16-bit axes mapping
  osbool mapped16 = find_and_map_x_y_16(i, AXIS_X, AXIS_Y);

  if (!mapped16)
    mapped16 = find_and_map_x_y_8(i, AXIS_DPADX, AXIS_DPADY);

  if (!mapped16)
    mapped16 = find_and_map_x_y_8(i, AXIS_HATX, AXIS_HATY);

  // Auto flip any axes that this 'driver' wants us to
  for (unsigned int a=0; a<joy_data[i].device->auto_flip_axes_length; a++) {
    for (unsigned int j=0; j<joy_data[i].num_axes; j++) {
      if (joy_data[i].axes[j].type == joy_data[i].device->auto_flip_axes[a])
        joy_data[i].axes[j].flip = TRUE;
    }
  }

  // Automatically map the buttons
  unsigned int maxbutton = joy_data[i].num_buttons;

  if (joy_data[i].num_buttons > ACORN_BUTTONS)
    maxbutton = ACORN_BUTTONS;

  for (unsigned int b=0; b<maxbutton; b++)
    joy_data[i].mapped_buttons[b] = b;

  // Automatically assign a 'stick number' based on the higest used so far
  int highest_stick = NOT_MAPPED;
  for (unsigned int j=0; j<JOY_MAX; j++) {
    if (joy_data[j].mapped_number > highest_stick)
      highest_stick = joy_data[j].mapped_number;
  }

  if (highest_stick == NOT_MAPPED)
    joy_data[i].mapped_number = 0;
  else
    joy_data[i].mapped_number = highest_stick + 1;

}





void unmap(unsigned int i)
{
  // don't need to do anything if we were not mapped
  if (joy_data[i].mapped_number == NOT_MAPPED)
    return;

  // decrement any higher mapped stick numbers
  int old_map = joy_data[i].mapped_number;
  joy_data[i].mapped_number = NOT_MAPPED;

  for (unsigned int j=0; j<JOY_MAX; j++) {
    if (joy_data[j].mapped_number > old_map)
      joy_data[j].mapped_number--;
  }

}





osbool find_and_map_x_y_8(unsigned int i, unsigned int x_type, unsigned int y_type)
{
  int x = NOT_MAPPED;
  int y = NOT_MAPPED;

  for (unsigned int j=0; j<joy_data[i].num_axes; j++) {
    if (joy_data[i].axes[j].type == x_type)
      x = j;
    else if (joy_data[i].axes[j].type == y_type)
      y = j;
  }

  if (x != NOT_MAPPED && y != NOT_MAPPED) {
      joy_data[i].mapped_x_8 = x;
      joy_data[i].mapped_y_8 = y;
      return true;
  }
  else {
    return false;
  }
}




osbool find_and_map_x_y_16(unsigned int i, unsigned int x_type, unsigned int y_type)
{
  int x = NOT_MAPPED;
  int y = NOT_MAPPED;

  for (unsigned int j=0; j<joy_data[i].num_axes; j++) {
    if (joy_data[i].axes[j].type == x_type)
      x = j;
    else if (joy_data[i].axes[j].type == y_type)
      y = j;
  }

  if (x != NOT_MAPPED && y != NOT_MAPPED) {
      joy_data[i].mapped_x_16 = x;
      joy_data[i].mapped_y_16 = y;
      return true;
  }
  else {
    return false;
  }
}





void joy_remove_device(const char* device_name)
{
  debug_printf("Removing device %s\n", device_name);
  for (unsigned int i=0; i<JOY_MAX; i++)
  {
    if (strcmp(joy_data[i].device_name, device_name) == 0) {
      if (joy_data[i].fp > 0) {
        os_error* error = xosfind_closew(joy_data[i].fp);
        if (error) {
          debug_printf("Cannot close fp %d when device %s is removed: %s", joy_data[i].fp, device_name, error->errmess);
        }
      }
      unmap(i);
      clean_joystick_data_item(i);
    }
  }
}




unsigned int next_available_joystick_index(void)
{
  for (unsigned int i=0; i<JOY_MAX; i++)
  {
    if (joy_data[i].in_use == FALSE)
      return i;
  }
  return NONE_AVAILABLE;
}




void clean_joystick_data(void)
{
  for (unsigned int i=0; i<JOY_MAX; i++)
    clean_joystick_data_item(i);

  adc_map.joy_id = NOT_MAPPED;
  adc_map.channel0 = NOT_MAPPED;
  adc_map.channel1 = NOT_MAPPED;
  adc_map.channel2 = NOT_MAPPED;
  adc_map.channel3 = NOT_MAPPED;
  adc_map.fire0 = NOT_MAPPED;
  adc_map.fire1 = NOT_MAPPED;

  adc_data.channels_to_be_sampled = 4;
  adc_data.current_channel = 1;
  adc_data.channel0 = 0;
  adc_data.channel1 = 0;
  adc_data.channel2 = 0;
  adc_data.channel3 = 0;
  adc_data.fire0 = 0;
  adc_data.fire1 = 0;
}





void clean_joystick_data_item(unsigned int i)
{
  unsigned int j;

  joy_data[i].report_length = 0;

  joy_data[i].has_report_id = FALSE;

  joy_data[i].device = NULL;

  free(joy_data[i].data_buf);
  joy_data[i].data_buf = NULL;

  for (j=0; j<JOY_AXES; j++) {
    free(joy_data[i].axes_items[j]);
    joy_data[i].axes_items[j] = NULL;
  }

  for (j=0; j<JOY_BUTTONS; j++) {
    free(joy_data[i].button_items[j]);
    joy_data[i].button_items[j] = NULL;
  }

  free(joy_data[i].hat_item);
  free(joy_data[i].dpad_up_item);
  free(joy_data[i].dpad_down_item);
  free(joy_data[i].dpad_left_item);
  free(joy_data[i].dpad_right_item);
  joy_data[i].hat_item = NULL;
  joy_data[i].dpad_up_item = NULL;
  joy_data[i].dpad_down_item = NULL;
  joy_data[i].dpad_left_item = NULL;
  joy_data[i].dpad_right_item = NULL;

  // these will only be valid if we actually have a HAT/DPAD
  joy_data[i].hat_axis = 0;
  joy_data[i].dpad_axis = 0;

  joy_data[i].has_dpad = FALSE;
  joy_data[i].has_hat = FALSE;

  joy_data[i].num_axes = 0;
  joy_data[i].num_buttons = 0;

  for (j=0; j<JOY_AXES; j++) {
    joy_data[i].axes[j].val = 0;
    joy_data[i].axes[j].min = 0;
    joy_data[i].axes[j].mid = 0;
    joy_data[i].axes[j].max = 0;
    joy_data[i].axes[j].acorn_slope_8 = 1;
    joy_data[i].axes[j].acorn_slope_16 = 1;
    joy_data[i].axes[j].adc_slope = 1;
    joy_data[i].axes[j].serial_port_upper_bound = 0;
    joy_data[i].axes[j].serial_port_lower_bound = 0;
    joy_data[i].axes[j].is_digital = FALSE;
    joy_data[i].axes[j].name = NULL;
    joy_data[i].axes[j].flip = FALSE;
  }

  for (j=0; j<JOY_BUTTONS; j++)
    joy_data[i].buttons[j] = 0;

  joy_data[i].in_use = FALSE;

  joy_data[i].open = FALSE;

  for (j=0; j<USB_DEVICE_NAME_LENGTH; j++)
    joy_data[i].device_name[j] = NULL;

  joy_data[i].interface = 0;
  joy_data[i].endpoint = 0;

  for (j=0; j<USB_DEVICEFS_PATH_MAX_LENGTH; j++)
    joy_data[i].usb_path[j] = NULL;

  joy_data[i].fp = NULL;
  joy_data[i].devicefs_handle = NULL;
  joy_data[i].buffer_handle = NULL;
  joy_data[i].buffer_internal_id = NULL;
  joy_data[i].buffer_service_routine = NULL;
  joy_data[i].buffer_workspace = NULL;

  joy_data[i].upcalls = 0;
  joy_data[i].upcalls_delta = 0;

  for (j=0; j<USB_MAX_STRING_LEN; j++) {
    joy_data[i].manufacturer[j] = NULL;
    joy_data[i].product[j] = NULL;
    joy_data[i].serial[j] = NULL;
  }

  joy_data[i].vendor_id = 0;
  joy_data[i].product_id = 0;
  joy_data[i].device_id = 0;

  joy_data[i].good_reads = 0;
  joy_data[i].good_reads_delta = 0;

  joy_data[i].bad_reads = 0;
  joy_data[i].bad_reads_delta = 0;

  joy_data[i].mapped_number = NOT_MAPPED;

  joy_data[i].mapped_x_8 = NOT_MAPPED;
  joy_data[i].mapped_y_8 = NOT_MAPPED;
  joy_data[i].mapped_x_16 = NOT_MAPPED;
  joy_data[i].mapped_y_16 = NOT_MAPPED;

  for (j=0; j<ACORN_BUTTONS; j++)
    joy_data[i].mapped_buttons[j] = NOT_MAPPED;
}







_kernel_oserror* joy_check_device(const usb_service_t* dev, void* handle)
{
  // check this usb device (dev is a connected usb device) to see if it looks like a joystick

  debug_printf(".\n");
  debug_printf("Checking device name '%s' (sum_length %u, descriptors_offset %u, class %02x, subclass %02x, protocol %02x)\n",
    dev->name,
    dev->sum_length,
    dev->descriptors_offset,
    dev->device.bDeviceClass,
    dev->device.bDeviceSubClass,
    dev->device.bDeviceProtocol);

  // 'dev->name' is 'USB4' for example, which is our 'connected USB device' handle
  usb_device_t* device = (usb_device_t*) dev->name;

  usb_device_descriptor_t* ddesc = NULL;
  usb_config_descriptor_t* cdesc = NULL;
  usb_string_descriptor_t* sdesc = NULL;
  usb_interface_descriptor_t* idesc = NULL;
  usb_endpoint_descriptor_t* edesc = NULL;
  uint32_t csDeviceClass = 0;
  uint32_t csInterfaceClass = 0;

  usb_descriptor_t *des = usb_get_descriptor_list(dev);

  // track if we've parsed something successfully - if so, we back-fill interface+endpoint info
  osbool got_valid_joystick = FALSE;

  for (char* pos=(char*)des; des->bLength; pos+=des->bLength,des=(usb_descriptor_t*)pos)
  {
    osbool unknown = FALSE;
    switch (des->bDescriptorType)
    {
      case USB_DEVICE_DESCRIPTOR:
        {
          ddesc = (usb_device_descriptor_t*)pos;
          csDeviceClass = ((ddesc->bDeviceClass << 16) | (ddesc->bDeviceSubClass << 8) | ddesc->bDeviceProtocol);
          debug_printf("Device descriptor: Length=%d, Type=%d, Configurations=%d, csDeviceClass=0x%x\n", ddesc->bLength, ddesc->bDescriptorType, ddesc->bNumConfigurations, csDeviceClass);
          debug_printf("Device descriptor: iManufacturer=%d, iProduct=%d, iSerialNumber=%d\n", ddesc->iManufacturer, ddesc->iProduct, ddesc->iSerialNumber);
          debug_printf("Device descriptor: Vendor=0x%04x, Product=0x%04x, Device=0x%04x\n", ddesc->idVendor, ddesc->idProduct, ddesc->bcdDevice);
        }
        break;

      case USB_CONFIGURATION_DESCRIPTOR:
        {
          cdesc = (usb_config_descriptor_t*)pos;
          debug_printf("Configuration descriptor: NumInterfaces=%d \n", cdesc->bNumInterface);
        }
        break;

      case USB_STRING_DESCRIPTOR:
        {
          sdesc = (usb_string_descriptor_t*)pos;
          debug_printf("String descriptor: Length=%d, Type=%d, String=%d \n", sdesc->bLength, sdesc->bDescriptorType, sdesc->bString);
        }
        break;

      case USB_INTERFACE_DESCRIPTOR:
        {
          idesc = (usb_interface_descriptor_t*)pos;
          csInterfaceClass = ((idesc->bInterfaceClass << 16) | (idesc->bInterfaceSubClass << 8) | idesc->bInterfaceProtocol);
          debug_printf("Interface descriptor: InterfaceNumber=%d, InterfaceClass=%d (3 is HID), iInterface=%d, csInterfaceClass=0x%x\n", idesc->bInterfaceNumber, idesc->bInterfaceClass, idesc->iInterface, csInterfaceClass);
        }
        break;

      case USB_ENDPOINT_DESCRIPTOR:
        {
          edesc = (usb_endpoint_descriptor_t*)pos;
          debug_printf("Endpoint descriptor: EndpointAddress=%d, (on TnterfaceNumber=%d)\n", edesc->bEndpointAddress, idesc->bInterfaceNumber);
          if (got_valid_joystick == TRUE)
          {
            debug_printf("Endpoint descriptor: We think this is a joystick (got HID report descriptor and it looks good), so set up\n");
            set_up_joystick(dev, device, ddesc, idesc, edesc);
            // reset validity so we can re-test the next endpoint
            got_valid_joystick = FALSE;
          }
          else
          {
            debug_printf("Endpoint descriptor: We think this isn't a joystick - ignore this endpoint\n");
          }
        }
        break;

      default:
        {
          debug_printf("Other descriptor: type is %d - not Device/Config/Interface/Endpoint\n", des->bDescriptorType);
          debug_printf("csDeviceClass 0x%x, csInterfaceClass 0x%x\n", csDeviceClass, csInterfaceClass);
          debug_printf("InterfaceClass 0x%x, InterfaceSubClass 0x%x, InterfaceProtocol %u, Vendor 0x%04x, Product 0x%04x\n", idesc->bInterfaceClass, idesc->bInterfaceSubClass, idesc->bInterfaceProtocol, ddesc->idVendor, ddesc->idProduct);

          struct joy_device_struct *joy_device = lookup_joy_device(idesc->bInterfaceClass, idesc->bInterfaceSubClass, idesc->bInterfaceProtocol, ddesc->idVendor, ddesc->idProduct);
          if (joy_device) {
            debug_printf("Supported device: %s\n", joy_device->name);
            void *report_descriptor = joy_device->report_descriptor;
            uint8_t report_descriptor_length = joy_device->report_descriptor_length;
            if (report_descriptor == 0) {
              // this device doesn't need a baked-in descriptor, so get it from the device
              usb_hid_device_descriptor_t* hdesc = (usb_hid_device_descriptor_t*)pos;
              report_descriptor_length = hdesc->wReportDescLength;
              report_descriptor = get_report_descriptor(device, hdesc);
            }
            if (report_descriptor == 0) {
              debug_printf("Cannot get HID report descriptor for device - aborting\n");
            }
            else {
              // now report_descriptor is a valid HID report descriptor
              // note that joy_index will be moved on by this next function
              got_valid_joystick = parse_usb_hid_device_descriptor(report_descriptor_length, report_descriptor);
              debug_printf("Parsed HID report descriptor, got_valid_joystick is %d\n", got_valid_joystick);
              // perform custom init sequence
              if (got_valid_joystick && joy_device->init_command_length > 0) {
                _kernel_oserror* e = usb_hid_set_output_report(device, idesc->bInterfaceNumber, joy_device->init_command, joy_device->init_command_length);
                if (e) {
                  debug_printf("Unable to initialise device %s: %s\n", device, e->errmess);
                }
              }
              // note device driver info
              if (got_valid_joystick)
                joy_data[joy_index].device = joy_device;
              // we need to free the memory used by getting our own descriptor
              if (joy_device->report_descriptor == 0) {
                free(report_descriptor);
              }
            }
          }
          else {
            debug_printf("Not a supported device - aborting\n");
          }

          if (unknown)
            debug_printf("Unknown descriptor\n");
        }
    }
  }

  IGNORE(handle);

  return NULL;

}





struct joy_device_struct *lookup_joy_device(uint8_t iClass, uint8_t iSubClass, uint8_t iProtocol, uint16_t vendor, uint16_t product)
{
  // look for a full match
  for (unsigned int i=0; i<joy_devices_count; i++) {
    if (joy_devices[i].interface_class == iClass &&
      joy_devices[i].interface_subclass == iSubClass &&
      joy_devices[i].interface_protocol == iProtocol &&
      joy_devices[i].vendor_id == vendor &&
      joy_devices[i].product_id == product)
      return (struct joy_device_struct*)&(joy_devices[i]);
  }

  // look for a match without vendor and product ids
  for (unsigned int i=0; i<joy_devices_count; i++) {
    if (joy_devices[i].interface_class == iClass &&
      joy_devices[i].interface_subclass == iSubClass &&
      joy_devices[i].interface_protocol == iProtocol &&
      joy_devices[i].vendor_id == 0 &&
      joy_devices[i].product_id == 0)
      return (struct joy_device_struct*)&(joy_devices[i]);
  }

  return 0;
}






uint8_t *get_report_descriptor(usb_device_t* device, usb_hid_device_descriptor_t *hdesc)
{
  int report_descriptor_type = UT_GET_TYPE(hdesc->bReportDescType);
  int report_descriptor_id = (hdesc->bReportDescType & 0xf);

  debug_printf("Device HID descriptor: Length=%d, Type=%d, ReportDescType=%d, NumDes=%d, ReportDescrLen=%d (RDType=%d, RDId=%d)\n", hdesc->bLength, hdesc->bDescriptorType, hdesc->bReportDescType, hdesc->bNumDescriptors, hdesc->wReportDescLength, report_descriptor_type, report_descriptor_id);

  if (report_descriptor_type == UT_CLASS && report_descriptor_id == 2) {
    uint8_t *hidrepdesc = calloc(1, hdesc->wReportDescLength);
    if (hidrepdesc != NULL)
    {
      debug_printf("Getting HID report descriptor\n");
      _kernel_oserror* e = usb_get_descriptor(device, hdesc->bReportDescType, hdesc->wReportDescLength, hidrepdesc);
      if (e)
      {
        debug_printf("Unable to get HID report descriptor: %s\n", e->errmess);
        free(hidrepdesc);
      }
      else
      {
        return hidrepdesc;
      }
    }
    else {
      debug_printf("Failed to allocate memory for getting HID report descriptor - aborting\n");
    }
  }
  else {
    debug_printf("report_descriptor_type is wrong (must be %u) and/or report_descriptor_id is wrong (must be 2) - aborting\n", UT_CLASS);
  }

  return 0;

}





void set_up_joystick(const usb_service_t* dev, usb_device_t* device, usb_device_descriptor_t* ddesc, usb_interface_descriptor_t* idesc, usb_endpoint_descriptor_t* edesc)
{
  debug_printf("Set up: Fill up joystick info\n");

  // ids
  joy_data[joy_index].vendor_id = ddesc->idVendor;
  joy_data[joy_index].product_id = ddesc->idProduct;
  joy_data[joy_index].device_id = ddesc->bcdDevice;

  // grab product/manufacturer/serial strings
  if (ddesc->iManufacturer > 0) {
    usb_string_descriptor_t *man = usb_get_device_string_descriptor(device, ddesc->iManufacturer);
    if (man) {
      usb_string_descriptor_to_ascii(man, joy_data[joy_index].manufacturer);
      debug_printf("Set up: Manufacturer: %s\n", joy_data[joy_index].manufacturer);
      free((void*)man);
    }
  }

  if (ddesc->iProduct > 0) {
    usb_string_descriptor_t *product = usb_get_device_string_descriptor(device, ddesc->iProduct);
    if (product) {
      usb_string_descriptor_to_ascii(product, joy_data[joy_index].product);
      debug_printf("Set up: Product: %s\n", joy_data[joy_index].product);
      free((void*)product);
    }
  }

  if (ddesc->iSerialNumber > 0) {
    usb_string_descriptor_t *serial = usb_get_device_string_descriptor(device, ddesc->iSerialNumber);
    if (serial) {
      usb_string_descriptor_to_ascii(serial, joy_data[joy_index].serial);
      debug_printf("Set up: Serial: %s\n", joy_data[joy_index].serial);
      free((void*)serial);
    }
  }

  // construct devicefs path
  memcpy(joy_data[joy_index].device_name, dev->name, USB_DEVICE_NAME_LENGTH);
  joy_data[joy_index].interface = idesc->bInterfaceNumber;
  joy_data[joy_index].endpoint = edesc->bEndpointAddress & 0x1f;
  sprintf(joy_data[joy_index].usb_path, USB_PATH_SPECIFIER, joy_data[joy_index].interface, joy_data[joy_index].endpoint, joy_data[joy_index].device_name);
  debug_printf("Set up: Constructed DeviceFS path for stick id %u, path is: %s\n", joy_index, joy_data[joy_index].usb_path);

  // start talking to it
  debug_printf("Set up: Open a connection to the joystick (id is %u)\n", joy_index);
  open_joystick(joy_index);
}






osbool parse_usb_hid_device_descriptor(unsigned int length, uint8_t* buf)
{
  osbool is_joystick = FALSE;
  osbool got_something = FALSE;
  report_desc_t rd = NULL;

  joy_index = next_available_joystick_index();
  if (joy_index == NONE_AVAILABLE)
  {
    debug_printf("Cannot parse this HID device descriptor - we have run out of joysticks!\n");
    return FALSE;
  }
  debug_printf("Will use joystick number %d (next available) for this HID parse\n", joy_index);

  joy_data[joy_index].in_use = TRUE;

  // share HID report descriptor data with libusbhid
  rd = hid_use_report_desc(buf, length);

  if (rd == NULL) {
    debug_printf("Failed to share report descriptor with libusbhid - aborting parse\n");
    return FALSE;
  }

  debug_printf("Shared report descriptor 'rd' (size=%u) with libusbhid\n", rd->size);

  // report_id is 0 by default, but some devices need a different value
  // todo: this could be dubious: what if we need to support MULTIPLE reportids?  Would they be two sticks?!
  joy_data[joy_index].has_report_id = FALSE;
  int report_id = NO_REPORT_ID;
  int custom_report_id = hid_get_report_id(rd);       // returns -1 for 'not used/applicable'
  if (custom_report_id > 0) {
    debug_printf("HID report descriptors use a reportid, so switching from %d to %d\n", report_id, custom_report_id);
    report_id = custom_report_id;
    joy_data[joy_index].has_report_id = TRUE;
  }

  // we only want to see inputs
  unsigned int size = hid_report_size(rd, hid_input, report_id);

  // todo: does this size include the 1st byte that might be a reportid?  
  joy_data[joy_index].report_length = size;

  if (size > 0) {
    debug_printf("Got hid report size %d for reportid %d, has_report_id is %d\n", size, report_id, joy_data[joy_index].has_report_id);
  }
  else {
    debug_printf("Error: HID report size is zero, abandoning parse\n");
    clean_joystick_data_item(joy_index);
    return FALSE;
  }

  // reserve space for storing raw data (now we know the required size)
  joy_data[joy_index].data_buf = malloc(size);
  if (joy_data[joy_index].data_buf == NULL)
  {
    debug_printf("Error: Not enough memory for joystick raw report data buffer.\n");
    clean_joystick_data_item(joy_index);
    return FALSE;
  }

  // initialise parsing data

  struct hid_data *d;
  struct hid_item h;

  // start parsing

  debug_printf("Starting parse of HID report descriptor\n");
  unsigned int l = 1;
  IGNORE(l);
  for (d = hid_start_parse(rd, 1 << hid_input, report_id); hid_get_item(d, &h); )
  {
    int page = HID_PAGE(h.usage);
    int usage = HID_USAGE(h.usage);

    //debug_printf("HID parser 1: l=%u, pos=%u, h.usage=0x%x, page=0x%x, usage=0x%x, kind=%d, reportid=%d\n", l++, h.pos, h.usage, page, usage, h.kind, h.report_ID);

    is_joystick = is_joystick ||
        (
            h.kind == hid_collection &&
            page == HUP_GENERIC_DESKTOP &&
            (usage == HUG_JOYSTICK || usage == HUG_GAME_PAD)
        );

    if (h.kind != hid_input) continue;

    if (!is_joystick) continue;

    //debug_printf("HID parser 2: is_joystick=%d\n", is_joystick);

    if (page == HUP_GENERIC_DESKTOP)
    {
      if (usage == HUG_HAT_SWITCH)
      {
        got_something = TRUE;
        if (joy_data[joy_index].hat_item == NULL) {
          debug_printf("HID parser:   reportid=%d, got HAT switch, copying\n", h.report_ID);
          joy_data[joy_index].hat_item = itemdup(&h);
        }
      }

      else if (usage == HUG_DPAD_UP)
      {
        got_something = TRUE;
        if (joy_data[joy_index].dpad_up_item == NULL) {
          debug_printf("HID parser:   reportid=%d, got dpad up, copying\n", h.report_ID);
          joy_data[joy_index].dpad_up_item = itemdup(&h);
        }
      }

      else if (usage == HUG_DPAD_DOWN)
      {
        got_something = TRUE;
        if (joy_data[joy_index].dpad_down_item == NULL) {
          debug_printf("HID parser:   reportid=%d, got dpad down, copying\n", h.report_ID);
          joy_data[joy_index].dpad_down_item = itemdup(&h);
        }
      }

      else if (usage == HUG_DPAD_LEFT)
      {
        got_something = TRUE;
        if (joy_data[joy_index].dpad_left_item == NULL) {
          debug_printf("HID parser:   reportid=%d, got dpad left, copying\n", h.report_ID);
          joy_data[joy_index].dpad_left_item = itemdup(&h);
        }
      }

      else if (usage == HUG_DPAD_RIGHT)
      {
        got_something = TRUE;
        if (joy_data[joy_index].dpad_right_item == NULL) {
          debug_printf("HID parser:   reportid=%d, got dpad right, copying\n", h.report_ID);
          joy_data[joy_index].dpad_right_item = itemdup(&h);
        }
      }

      else if (supported_axes_usage[usage])
      {
        unsigned int type = supported_axes_usage[usage];
        debug_printf("HID parser:   reportid=%d, got supported axis, usage is 0x%x, type is %u\n", h.report_ID, usage, type);
        got_something = TRUE;
        // see if we can find somewhere to copy the axis item
        for (unsigned int j=0; j<JOY_USAGE_AXES; j++) {
          if (joy_data[joy_index].axes_items[j] == NULL) {
            debug_printf("HID parser:   copying axis HID item to index %u\n", j);
            joy_data[joy_index].axes_items[j] = itemdup(&h);
            break;
          }
          else {
            //debug_printf("HID parser:   index %u is full, will try next index\n", j);
          }
        }
      }

      else
      {
        debug_printf("HID parser:   reportid=%d, usage is unsupported (not axis/dpad/hat, code 0x%x)\n", h.report_ID, usage);
      }

    }

    else if (page == HUP_BUTTON)
    {
      if ((usage > 0) && (usage <= JOY_BUTTONS))
      {
        got_something = TRUE;
        debug_printf("HID parser:   reportid=%d, got button, setting up button %d\n", h.report_ID, usage-1);

        if (joy_data[joy_index].button_items[usage-1] == NULL)
          joy_data[joy_index].button_items[usage-1] = itemdup(&h);

        if (usage > joy_data[joy_index].num_buttons)
          joy_data[joy_index].num_buttons = usage;
      }
    }

    else
    {
      debug_printf("HID parser:   reportid=%d, ignoring item\n", h.report_ID);
    }

  }  // end of for (each hid_item)

  hid_end_parse(d);
  debug_printf("Parse completed - freeing libusbhid report descriptor memory\n");
  hid_dispose_report_desc(rd);

  if (!got_something)
  {
    // nothing useful in this hid descriptor
    debug_printf("Got nothing - free raw data buffer memory and exit\n");
    clean_joystick_data_item(joy_index);
    return FALSE;
  }

  debug_printf("Analysing parse output to build axes info\n");

  // set up analogue axes
  for (unsigned int j=0; j<JOY_USAGE_AXES; j++)
  {
    struct hid_item *hid_item = joy_data[joy_index].axes_items[j];
    if (hid_item != NULL)
    {
      // we have a HID item for an axis, so build an axisdata_struct for it
      struct axisdata_struct *axis = &(joy_data[joy_index].axes[j]);
      joy_data[joy_index].num_axes++;

      unsigned int item_usage = HID_USAGE(hid_item->usage);

      axis->type = supported_axes_usage[item_usage];
      axis->name = (char*)axes_names[axis->type];
      axis->min = hid_item->logical_minimum;
      axis->max = hid_item->logical_maximum;
      axis->mid = ((axis->max - axis->min + 1) / 2) + axis->min;
      axis->val = axis->mid;
      axis->is_digital = FALSE;

      debug_printf("Axis %d, item_usage is %u, type is %u, name is %s\n", j, item_usage, axis->type, axis->name);
      
      unsigned int range = (axis->max) - (axis->min);
      unsigned int deadzone = (range) / 8;

      axis->serial_port_lower_bound = axis->mid - deadzone;
      axis->serial_port_upper_bound = axis->mid + deadzone;

      axis->acorn_slope_8 = (float)ACORN_AXIS_VALUES_8 / (float)range;
      axis->acorn_slope_16 = (float)ACORN_AXIS_VALUES_16 / (float)range;
      axis->adc_slope = (float)ADC_AXIS_VALUES / (float)range;
    }
  }

  // if we have a HAT switch, then add two axes for it (x and y), if we have spare slots
  if (joy_data[joy_index].hat_item)
  {
    if (joy_data[joy_index].num_axes < JOY_AXES-2)
    {
      debug_printf("Stick has HAT switch and we have two axes spare to use\n");
      joy_data[joy_index].has_hat = TRUE;
      unsigned int n = joy_data[joy_index].num_axes;
      joy_data[joy_index].num_axes += 2;
      joy_data[joy_index].hat_axis = n;
      joy_data[joy_index].axes[n].type = AXIS_HATX;
      joy_data[joy_index].axes[n].name = (char*)axes_names[AXIS_HATX];
      joy_data[joy_index].axes[n+1].type = AXIS_HATY;
      joy_data[joy_index].axes[n+1].name = (char*)axes_names[AXIS_HATY];
      for (unsigned int j=0; j<2; j++)
      {
        joy_data[joy_index].axes[n+j].min = -1;
        joy_data[joy_index].axes[n+j].max = 1;
        joy_data[joy_index].axes[n+j].mid = 0;
        joy_data[joy_index].axes[n+j].val = 0;
        joy_data[joy_index].axes[n+j].serial_port_lower_bound = 0;
        joy_data[joy_index].axes[n+j].serial_port_upper_bound = 0;
        joy_data[joy_index].axes[n+j].acorn_slope_8 = 1;
        joy_data[joy_index].axes[n+j].acorn_slope_16 = 1;
        joy_data[joy_index].axes[n+j].adc_slope = 1;
        joy_data[joy_index].axes[n+j].is_digital = TRUE;
      }
    }
    else
    {
      // too many axes to support hat
      debug_printf("Too many axis to support HAT (got %d, max is %d ) - exiting\n", joy_data[joy_index].num_axes, JOY_AXES-1);
      clean_joystick_data_item(joy_index);
    }
  }

  // if we have a dpad, then add two axes for it (x and y), if we have spare slots
  if (joy_data[joy_index].dpad_up_item &&
      joy_data[joy_index].dpad_down_item &&
      joy_data[joy_index].dpad_left_item &&
      joy_data[joy_index].dpad_right_item)
  {
    if (joy_data[joy_index].num_axes < JOY_AXES-2)
    {
      debug_printf("Stick has DPAD and we have two axes spare to use\n");
      joy_data[joy_index].has_dpad = TRUE;
      unsigned int n = joy_data[joy_index].num_axes;
      joy_data[joy_index].num_axes += 2;
      joy_data[joy_index].dpad_axis = n;
      joy_data[joy_index].axes[n].type = AXIS_DPADX;
      joy_data[joy_index].axes[n].name = (char*)axes_names[AXIS_DPADX];
      joy_data[joy_index].axes[n+1].type = AXIS_DPADY;
      joy_data[joy_index].axes[n+1].name = (char*)axes_names[AXIS_DPADY];
      for (unsigned int j=0; j<2; j++)
      {
        joy_data[joy_index].axes[n+j].min = -1;
        joy_data[joy_index].axes[n+j].max = 1;
        joy_data[joy_index].axes[n+j].mid = 0;
        joy_data[joy_index].axes[n+j].val = 0;
        joy_data[joy_index].axes[n+j].serial_port_lower_bound = 0;
        joy_data[joy_index].axes[n+j].serial_port_upper_bound = 0;
        joy_data[joy_index].axes[n+j].acorn_slope_8 = 1;
        joy_data[joy_index].axes[n+j].acorn_slope_16 = 1;
        joy_data[joy_index].axes[n+j].adc_slope = 1;
        joy_data[joy_index].axes[n+j].is_digital = TRUE;
      }
    }
    else
    {
      // too many axes to support dpad
      debug_printf("Too many axis to support DPAD (got %d, max is %d ) - exiting\n", joy_data[joy_index].num_axes, JOY_AXES-1);
      clean_joystick_data_item(joy_index);
    }
  }

  debug_printf("Joystick/gamepad parsed and configured successfully (joy_index is %d)\n", joy_index);

  return TRUE;
}





void joystick_decode(unsigned int i)
{
  /* 0   1   2   3   4   5   6   7 */
  /* u  ru  r   rd   d  ld  l   lu */

  const int hat_x[] = {
     0,  1,  1,  1,  0, -1, -1, -1
  };
  const int hat_y[] = {
    -1, -1,  0,  1,  1,  1,  0, -1
  };

  int d;
  unsigned int j;
  char *p = joy_data[i].data_buf;

  // extract the reportid byte (if there is one), falling back to 0 as a default for ('no report id')
  unsigned int reportid = 0;
  if (joy_data[i].has_report_id) {
    reportid = joy_data[i].data_buf[0];
    p++;
  }

  // run any custom validators on the data packet
  osbool valid = FALSE;
  if (joy_data[i].device->data_valid)
    valid = joy_data[i].device->data_valid(p);
  else
    valid = TRUE;

  if (!valid)
    return;

  // move past the data offset (if there is one - it may be zero)
  p = p + joy_data[i].device->report_data_offset;

  // now parse the HID report data (currently pointed to by p)
  for (j=0; j<joy_data[i].num_axes; j++)
  {
    if (joy_data[i].axes_items[j] && joy_data[i].axes_items[j]->report_ID == reportid) {
      joy_data[i].axes[j].val = hid_get_data(p, joy_data[i].axes_items[j]);
    }
  }

  if (joy_data[i].has_hat && joy_data[i].hat_item->report_ID == reportid)
  {
    d = hid_get_data(p, joy_data[i].hat_item) - joy_data[i].hat_item->logical_minimum;
    j = joy_data[i].hat_axis;
    if (d < 0 || d >= 8)
    {
      joy_data[i].axes[j].val = 0;
      joy_data[i].axes[j+1].val = 0;
    }
    else
    {
      joy_data[i].axes[j].val = hat_x[d];
      joy_data[i].axes[j+1].val = hat_y[d];
    }
  }

  if (joy_data[i].has_dpad)
  {
    j = joy_data[i].dpad_axis;

    // left/right (x axis)
    if (joy_data[i].dpad_left_item->report_ID == reportid && joy_data[i].dpad_right_item->report_ID == reportid) {
      d = hid_get_data(p, joy_data[i].dpad_left_item) - joy_data[i].dpad_left_item->logical_minimum;
      if (d) {
        joy_data[i].axes[j].val = -1;
      }
      else {
        d = hid_get_data(p, joy_data[i].dpad_right_item) - joy_data[i].dpad_right_item->logical_minimum;
        if (d) {
          joy_data[i].axes[j].val = 1;
        }
        else {
          joy_data[i].axes[j].val = 0;
        }
      }
    }

    // up/down (y axis)
    if (joy_data[i].dpad_up_item->report_ID == reportid && joy_data[i].dpad_down_item->report_ID == reportid) {
      d = hid_get_data(p, joy_data[i].dpad_up_item) - joy_data[i].dpad_up_item->logical_minimum;
      if (d) {
        joy_data[i].axes[j+1].val = -1;
      }
      else {
        d = hid_get_data(p, joy_data[i].dpad_down_item) - joy_data[i].dpad_down_item->logical_minimum;
        if (d) {
          joy_data[i].axes[j+1].val = 1;
        }
        else {
          joy_data[i].axes[j+1].val = 0;
        }
      }
    }
  }

  for (j=0; j<joy_data[i].num_buttons; j++)
  {
    if (joy_data[i].button_items[j] && joy_data[i].button_items[j]->report_ID == reportid)
      joy_data[i].buttons[j] = (hid_get_data(p, joy_data[i].button_items[j]) == joy_data[i].button_items[j]->logical_maximum);
  }
}





static struct hid_item *itemdup(struct hid_item *s)
{
  struct hid_item *t;

  t = malloc(sizeof(*t));
  if (t == NULL)
  {
    debug_printf("Error: itemdup: Not enough memory for joystick.\n");
    return NULL;
  }

  memcpy(t, s, sizeof(*t));

  return t;
}




_kernel_oserror *module_finalise(int fatal, int podule, void *pw)
{
  IGNORE(fatal);
  IGNORE(podule);

  os_error *error = NULL;

  if (upcall_claimed == TRUE) {
    error = xos_release(UpCallV, &upcallv_hook, pw);
    if (error) {
      debug_printf("Error in finalisation: failed to release upcallv, error number %d: %s\n", error->errnum, error->errmess);
    }
  }

  if (ukswiv_claimed == TRUE) {
    error = xos_release(UKSWIV, (asm_routine) ukswiv_pre_hook, pw);
    if (error) {
      debug_printf("Error in finalisation: failed to release ukswiv, error number %d: %s\n", error->errnum, error->errmess);
    }
  }

  if (bytev_claimed == TRUE) {
    error = xos_release(ByteV, &bytev_hook, pw);
    if (error) {
      debug_printf("Error in finalisation: failed to release bytev, error number %d: %s\n", error->errnum, error->errmess);
    }
  }

  // close down any USB file handles we had active
  for (unsigned int i=0; i<JOY_MAX; i++) {
    if (joy_data[i].fp != NULL) {
      error = xosfind_closew(joy_data[i].fp);
      if (error) {
        debug_printf("Error in finalisation: failed to close joystick %d fp, error number %d: %s\n", i, error->errnum, error->errmess);
      }
      joy_data[i].fp = 0;
    }
  }

  #ifndef ROM_MODULE
  error = xresourcefs_deregister_files((resourcefs_file_list *) Resources());
  if (error) {
    debug_printf("Error in finalisation: failed to degreister resources, error number %d: %s\n", error->errnum, error->errmess);
  }
  #endif

  // allow module to die
  return NULL;
}




_kernel_oserror *command_read(const char *args, int argc)
{
  if (argc != 1) {
    debug_printf("Read: Bad arguments, argc isn't 1 (it is %d)\n", argc);
    return &err_badnoparms;
  }

  os_error *error = NULL;
  unsigned int i;
  unsigned int ret = sscanf(args, "%d", &i);
  if (ret != 1) {
    debug_printf("Read: Bad arguments, didn't read 1 arg (read %d)\n", ret);
    return &err_badnoparms;
  }

  if (i >= JOY_MAX) {
    debug_printf("Read: Bad arguments, id (%d) is out of range\n", i);
    return &err_badnoparms;
  }

  if (!joy_data[i].in_use) {
    debug_printf("Read: Joystick id (%d) isn't active\n", i);
    return &err_joynotactive;
  }

  if (!joy_data[i].open) {
    debug_printf("Read: Joystick id (%d) isn't open\n", i);
    return &err_joynotopen;
  }

  debug_printf("Read: i=%u\n", i);

  printf("Joytstick id %u (%s - %s)\n", i, joy_data[i].manufacturer, joy_data[i].product);

  for (unsigned int a=0; a<joy_data[i].num_axes; a++) {
    printf("Axis %02d %6s : ", a, joy_data[i].axes[a].name);
    printf("Val=%8d  ", joy_data[i].axes[a].val);
    printf("Min=%8d  ", joy_data[i].axes[a].min);
    printf("Mid=%8d  ", joy_data[i].axes[a].mid);
    printf("Max=%8d  ", joy_data[i].axes[a].max);
    printf("Flip=");
    if (joy_data[i].axes[a].flip)
      printf("on");
    else
      printf("off");
    printf("\n");
  }

  printf("Buttons: ");
  for (unsigned int b=0; b<joy_data[i].num_buttons; b++) {
    printf("%u=%u ", b, joy_data[i].buttons[b]);
  }
  printf("\n");

  IGNORE(error);

  return NULL;
}





_kernel_oserror *command_map_buttons(const char *args, int argc)
{
  if (argc < 2 || argc > 17) {
    debug_printf("MapButtons: Bad arguments, argc is less than 2 or greater than 17 (it is %d)\n", argc);
    return &err_badnoparms;
  }

  const char s[2] = " ";
  char *t = NULL;

  unsigned int id = JOY_MAX;      // the usb joystick id
  unsigned int b[ACORN_BUTTONS];

  t = strtok((char*)args, s);
  if (t) id = atoi(t);
  if (id >= JOY_MAX) {
    debug_printf("MapButtons: Bad arguments, id (%d) is out of range\n", id);
    return &err_badnoparms;
  }

  // read button numbers from remaining arguments
  unsigned int cmd_buttons = argc - 1;

  for (unsigned int i=0; i<cmd_buttons; i++) {
    // i is the mapped button number
    t = strtok(NULL, s);
    if (t) {
      unsigned int button = atoi(t);
      if (button >= JOY_BUTTONS) {
        debug_printf("MapButtons: Bad arguments, button (%d) is too big\n", button);
        return &err_badnoparms;
      }
      b[i] = button;
    }
  }

  if (!joy_data[id].in_use) {
    debug_printf("MapButtons: Joystick id (%d) isn't active\n", id);
    return &err_joynotactive;
  }

  if (!joy_data[id].open) {
    debug_printf("MapButtons: Joystick id (%d) isn't open\n", id);
    return &err_joynotopen;
  }

  // clear out ALL mappings for this number
  for (unsigned int i=0; i<ACORN_BUTTONS; i++)
    joy_data[id].mapped_buttons[i] = NOT_MAPPED;

  // map the supplied button list up
  for (unsigned int i=0; i<cmd_buttons; i++)
    joy_data[id].mapped_buttons[i] = b[i];

  return NULL;
}







_kernel_oserror *command_map_axes(const char *args, int argc, osbool sixteenbit)
{
  if (argc != 3) {
    debug_printf("MapAxes: Bad arguments, argc is not 3 (it is %d)\n", argc);
    return &err_badnoparms;
  }

  const char s[2] = " ";
  char *t = NULL;

  unsigned int id = JOY_MAX;      // the usb joystick id
  unsigned int x = JOY_AXES;
  unsigned int y = JOY_AXES;

  t = strtok((char*)args, s);
  if (t) id = atoi(t);
  if (id >= JOY_MAX) {
    debug_printf("MapAxes: Bad arguments, id (%d) is too big\n", id);
    return &err_badnoparms;
  }

  // todo: limit x axis index to max axis for the particular joystick?
  t = strtok(NULL, s);
  if (t) x = atoi(t);
  if (x >= JOY_AXES) {
    debug_printf("MapAxes: Bad arguments, x (%d) is too big\n", x);
    return &err_badnoparms;
  }

  // todo: limit y axis index to max axis for the particular joystick?
  t = strtok(NULL, s);
  if (t) y = atoi(t);
  if (y >= JOY_AXES) {
    debug_printf("MapAxes: Bad arguments, y (%d) is too big\n", y);
    return &err_badnoparms;
  }

  if (!joy_data[id].in_use) {
    debug_printf("MapAxes: Joystick id (%d) isn't active\n", id);
    return &err_joynotactive;
  }

  if (!joy_data[id].open) {
    debug_printf("MapAxes: Joystick id (%d) isn't open\n", id);
    return &err_joynotopen;
  }

  // map these axes
  if (!sixteenbit) {
    joy_data[id].mapped_x_8 = x;
    joy_data[id].mapped_y_8 = y;
  }
  else {
    joy_data[id].mapped_x_16 = x;
    joy_data[id].mapped_y_16 = y;
  }

  return NULL;
}




_kernel_oserror *command_map_adc(const char *args, int argc)
{
  if (argc < 2 || argc > 7 ) {
    debug_printf("MapADC: Bad arguments, argc is not 3 (it is %d)\n", argc);
    return &err_badnoparms;
  }

  // *USBJoystick_MapADC <stick id> <ch0 axis> <ch1> <ch2> <ch3> <fire0> <fire1>

  const char s[2] = " ";
  char *t = NULL;

  unsigned int id = JOY_MAX;          // the usb joystick id
  unsigned int channel0 = JOY_AXES;
  unsigned int channel1 = JOY_AXES;
  unsigned int channel2 = JOY_AXES;
  unsigned int channel3 = JOY_AXES;
  unsigned int fire0 = JOY_BUTTONS;
  unsigned int fire1 = JOY_BUTTONS;

  t = strtok((char*)args, s);
  if (t) id = atoi(t);
  if (id >= JOY_MAX) {
    debug_printf("MapADC: Bad arguments, id (%d) is too big\n", id);
    return &err_badnoparms;
  }

  // todo: limit axis index to max axis for the particular joystick?
  t = strtok(NULL, s);
  if (t) channel0 = atoi(t);
  if (channel0 >= JOY_AXES) {
    debug_printf("MapADC: Bad arguments, channel0 (%d) is too big\n", channel0);
    return &err_badnoparms;
  }

  t = strtok(NULL, s);
  if (t) channel1 = atoi(t);
  if (channel1 >= JOY_AXES) {
    debug_printf("MapADC: Bad arguments, channel1 (%d) is too big\n", channel1);
    return &err_badnoparms;
  }

  t = strtok(NULL, s);
  if (t) channel2 = atoi(t);
  if (channel2 >= JOY_AXES) {
    debug_printf("MapADC: Bad arguments, channel2 (%d) is too big\n", channel2);
    return &err_badnoparms;
  }

  t = strtok(NULL, s);
  if (t) channel3 = atoi(t);
  if (channel3 >= JOY_AXES) {
    debug_printf("MapADC: Bad arguments, channel3 (%d) is too big\n", channel3);
    return &err_badnoparms;
  }

  // todo: limit buttons to max button for the particular joystick?
  t = strtok(NULL, s);
  if (t) fire0 = atoi(t);
  if (fire0 >= JOY_BUTTONS) {
    debug_printf("MapADC: Bad arguments, fire0 (%d) is too big\n", fire0);
    return &err_badnoparms;
  }

  t = strtok(NULL, s);
  if (t) fire1 = atoi(t);
  if (fire1 >= JOY_BUTTONS) {
    debug_printf("MapADC: Bad arguments, fire1 (%d) is too big\n", fire1);
    return &err_badnoparms;
  }

  if (!joy_data[id].in_use) {
    debug_printf("MapADC: Joystick id (%d) isn't active\n", id);
    return &err_joynotactive;
  }

  if (!joy_data[id].open) {
    debug_printf("MapADC: Joystick id (%d) isn't open\n", id);
    return &err_joynotopen;
  }

  // update the map
  adc_map.joy_id = id;
  adc_map.channel0 = channel0;
  adc_map.channel1 = channel1;
  adc_map.channel2 = channel2;
  adc_map.channel3 = channel3;
  adc_map.fire0 = fire0;
  adc_map.fire1 = fire1;

  // todo: above *command is too simplistic - need to allow for axis/channel sharing
  // need to check if an axis is shared across two channels (so combine them)
  // need to only allow an axis to be used once or twice (or bad params)

  return NULL;
}




_kernel_oserror *command_flip(const char *args, int argc)
{
  if (argc != 3) {
    debug_printf("Flip: Bad arguments, argc is not 3 (it is %d)\n", argc);
    return &err_badnoparms;
  }

  const char s[2] = " ";
  char *t = NULL;

  unsigned int id = JOY_MAX;      // the usb joystick id
  unsigned int axis = JOY_AXES;

  t = strtok((char*)args, s);
  if (t) id = atoi(t);
  if (id >= JOY_MAX) {
    debug_printf("Flip: Bad arguments, id (%d) is too big\n", id);
    return &err_badnoparms;
  }

  t = strtok(NULL, s);
  if (t) axis = atoi(t);
  if (axis >= JOY_AXES) {
    debug_printf("Flip: Bad arguments, axis (%d) is too big\n", axis);
    return &err_badnoparms;
  }

  // must have an on/off argument, so check if it's on or off
  t = strtok(NULL, s);
  osbool arg_on = (strncmp(t, "on", 2) == 0);
  osbool arg_off = (strncmp(t, "off", 3) == 0);

  if (!arg_on && !arg_off) {
    debug_printf("Flip: Bad arguments, not on or off (it is %t)\n", argc);
    return &err_badnoparms;
  }

  debug_printf("Flip: Setting flip on id=%d, axis=%d to %d\n", id, axis, arg_on);
  joy_data[id].axes[axis].flip = arg_on;

  return NULL;
}





_kernel_oserror *command_map_stick(const char *args, int argc)
{
  if (argc != 2) {
    debug_printf("Map: Bad arguments, argc is not 2 (it is %d)\n", argc);
    return &err_badnoparms;
  }

  const char s[2] = " ";
  char *t = NULL;

  unsigned int id = JOY_MAX;      // the usb joystick id (0-based)
  int number = JOY_MAX;           // the legacy api number (0-based)

  t = strtok((char*)args, s);
  if (t) id = atoi(t);
  if (id >= JOY_MAX) {
    debug_printf("Map: Bad arguments, id (%d) is too big\n", id);
    return &err_badnoparms;
  }

  t = strtok(NULL, s);
  if (t) number = atoi(t);
  if (number >= JOY_MAX) {
    debug_printf("Map: Bad arguments, number (%d) is out of range\n", number);
    return &err_badnoparms;
  }

  if (!joy_data[id].in_use) {
    debug_printf("Map: Joystick id (%d) isn't active\n", id);
    return &err_joynotactive;
  }

  if (!joy_data[id].open) {
    debug_printf("Map: Joystick id (%d) isn't open\n", id);
    return &err_joynotopen;
  }

  // clear out any other mappings for this number
  for (unsigned int i=0; i<JOY_MAX; i++) {
    if (joy_data[i].mapped_number == number) {
      joy_data[i].mapped_number = NOT_MAPPED;
    }
  }

  // map this one up
  joy_data[id].mapped_number = number;

  return NULL;
}










_kernel_oserror *command_emulate_acorn(const char *args, int argc)
{
  if (argc == 0) {
    printf("EmulateAcorn is ");
    if (emulate_acorn_on)
      printf("on\n");
    else
      printf("off\n");
    return NULL;
  }

  // must have one argument, so check if it's on or off
  int arg_on = (strncmp(args, "on", 2) == 0);
  int arg_off = (strncmp(args, "off", 3) == 0);

  if (!arg_on && !arg_off) {
    debug_printf("EmulateAcorn: Bad argument - must be on or off\n");
    return &err_badnoparms;
  }

  if (arg_on && emulate_acorn_on) {
    debug_printf("EmulateAcorn: Bad argument - already on\n");
    return &err_badnoparms;
  }

  if (arg_off && !emulate_acorn_on) {
    debug_printf("EmulateAcorn: Bad argument - already off\n");
    return &err_badnoparms;
  }

  emulate_acorn_on = arg_on;
  return NULL;
}




_kernel_oserror *command_emulate_serial_port(const char *args, int argc)
{
  if (argc == 0) {
    printf("EmulateSerialPort is ");
    if (emulate_serial_port_on)
      printf("on\n");
    else
      printf("off\n");
    return NULL;
  }

  // must have one argument, so check if it's on or off
  int arg_on = (strncmp(args, "on", 2) == 0);
  int arg_off = (strncmp(args, "off", 3) == 0);

  if (!arg_on && !arg_off) {
    debug_printf("EmulateSerialPort: Bad argument - must be on or off\n");
    return &err_badnoparms;
  }

  if (arg_on && emulate_serial_port_on) {
    debug_printf("EmulateSerialPort: Bad argument - already on\n");
    return &err_badnoparms;
  }

  if (arg_off && !emulate_serial_port_on) {
    debug_printf("EmulateSerialPort: Bad argument - already off\n");
    return &err_badnoparms;
  }

  emulate_serial_port_on = arg_on;
  return NULL;
}






_kernel_oserror *command_emulate_joy(const char *args, int argc)
{
  if (argc == 0) {
    printf("EmulateJoy is ");
    if (emulate_joy_on)
      printf("on\n");
    else
      printf("off\n");
    return NULL;
  }

  // must have one argument, so check if it's on or off
  int arg_on = (strncmp(args, "on", 2) == 0);
  int arg_off = (strncmp(args, "off", 3) == 0);

  if (!arg_on && !arg_off) {
    debug_printf("EmulateJoy: Bad argument - must be on or off\n");
    return &err_badnoparms;
  }

  if (arg_on && emulate_joy_on) {
    debug_printf("EmulateJoy: Bad argument - already on\n");
    return &err_badnoparms;
  }

  if (arg_off && !emulate_joy_on) {
    debug_printf("EmulateJoy: Bad argument - already off\n");
    return &err_badnoparms;
  }

  emulate_joy_on = arg_on;
  return NULL;
}




_kernel_oserror *command_emulate_adc(const char *args, int argc)
{
  if (argc == 0) {
    printf("EmulateADC is ");
    if (emulate_adc_on)
      printf("on\n");
    else
      printf("off\n");
    return NULL;
  }

  // must have one argument, so check if it's on or off
  int arg_on = (strncmp(args, "on", 2) == 0);
  int arg_off = (strncmp(args, "off", 3) == 0);

  if (!arg_on && !arg_off) {
    debug_printf("EmulateADC: Bad argument - must be on or off\n");
    return &err_badnoparms;
  }

  if (arg_on && emulate_adc_on) {
    debug_printf("EmulateADC: Bad argument - already on\n");
    return &err_badnoparms;
  }

  if (arg_off && !emulate_adc_on) {
    debug_printf("EmulateADC: Bad argument - already off\n");
    return &err_badnoparms;
  }

  emulate_adc_on = arg_on;
  return NULL;
}





_kernel_oserror *command_debug(const char *args, int argc)
{
  if (argc >= 1) {
    int desired_id = -1;
    unsigned int ret = sscanf(args, "%d", &desired_id);
    if (ret != 1) {
      debug_printf("Debug: Bad arguments, didn't read 1 args (read %d)\n", ret);
      return &err_badnoparms;
    }
  
    if (desired_id < 0 || desired_id >= JOY_MAX) {
      debug_printf("Debug: Bad arguments, id (%d) is too big\n", desired_id);
      return &err_badnoparms;
    }

    debug_printf("Debug: Printing out single stick id %d\n", desired_id);
    debug_joystick(desired_id);
  }
  else {
    osbool any = FALSE;
  
    for (unsigned int i=0; i<JOY_MAX; i++) {
      if (joy_data[i].in_use == TRUE) {
        debug_printf("Debug: Printing out all active sticks, currently on stick id %d\n", i);
        debug_joystick(i);
        any = TRUE;
      }
    }
  
    if (any == FALSE) {
      printf("No active joysticks.\n");
    }
  }

  return NULL;
}





_kernel_oserror *command_list(const char *args, int argc)
{
  if (argc >= 1) {
    int desired_id = -1;
    unsigned int ret = sscanf(args, "%d", &desired_id);
    if (ret != 1) {
      debug_printf("Map: Bad arguments, didn't read 1 args (read %d)\n", ret);
      return &err_badnoparms;
    }
  
    if (desired_id < 0 || desired_id >= JOY_MAX) {
      debug_printf("Map: Bad arguments, id (%d) is too big\n", desired_id);
      return &err_badnoparms;
    }

    debug_printf("List: Printing out single stick id %d\n", desired_id);
    print_joystick(desired_id);
  }
  else {
    osbool any = FALSE;
  
    for (unsigned int i=0; i<JOY_MAX; i++) {
      if (joy_data[i].in_use == TRUE) {
        debug_printf("List: Printing out all active sticks, currently on stick id %d\n", i);
        print_joystick(i);
        any = TRUE;
      }
    }
  
    if (any == FALSE) {
      printf("No active joysticks.\n");
    }
  }

  return NULL;
}




_kernel_oserror *command_mapped(const char *args, int argc)
{
  if (argc >= 1) {
    int i = -1;
    unsigned int ret = sscanf(args, "%d", &i);
    if (ret != 1) {
      debug_printf("Map: Bad arguments, didn't read 1 args (read %d)\n", ret);
      return &err_badnoparms;
    }
  
    if (i < 0 || i >= JOY_MAX) {
      debug_printf("Map: Bad arguments, id (%d) is too big\n", i);
      return &err_badnoparms;
    }

    debug_printf("List: Printing out single stick id %d\n", i);
    printf("Joystick id %u (%s - %s)\n", i, joy_data[i].manufacturer, joy_data[i].product);
    print_joystick_map(i);
  }
  else {
    osbool any = FALSE;
  
    for (unsigned int i=0; i<JOY_MAX; i++) {
      if (joy_data[i].in_use == TRUE && joy_data[i].mapped_number != NOT_MAPPED) {
        printf("Joystick id %u (%s - %s)\n", i, joy_data[i].manufacturer, joy_data[i].product);
        print_joystick_map(i);
        any = TRUE;
      }
    }
  
    if (any == FALSE) {
      printf("No mapped joysticks.\n");
    }
  }
  return NULL;
}





void print_joystick(unsigned int i)
{
  printf("Joystick id %u (%s - %s)\n", i, joy_data[i].manufacturer, joy_data[i].product);

  printf("  Local USB device name            : %s\n", joy_data[i].device_name);
  printf("  Interface                        : %d\n", joy_data[i].interface);
  printf("  Endpoint                         : %d\n", joy_data[i].endpoint);
  printf("  Device manufacturer              : %s\n", joy_data[i].manufacturer);
  printf("  Device product name              : %s\n", joy_data[i].product);
  printf("  Device serial number             : %s\n", joy_data[i].serial);
  printf("  Driver                           : %s\n", joy_data[i].device->name);

  printf("  Number of axes                   : %d\n", joy_data[i].num_axes);
  printf("  Number of buttons                : %d\n", joy_data[i].num_buttons);
                                       
  printf("  HAT switch                       : ");
  if (joy_data[i].hat_item)            
    printf("Yes\n");                   
  else                                 
    printf("No\n");                    
                                       
  printf("  DPAD                             : ");
  if (joy_data[i].has_dpad)            
    printf("Yes\n");
  else
    printf("No\n");

  //print_joystick_map(i);

}




void print_joystick_map(unsigned int i)
{
  printf("  Mapped to Joystick number        : ");
  if (joy_data[i].mapped_number == NOT_MAPPED)
    printf("N/A\n");
  else
    printf("%02d\n", joy_data[i].mapped_number);

  printf("  Mapped to Joystick  8-bit x-axis : ");
  if (joy_data[i].mapped_x_8 == NOT_MAPPED)
    printf("N/A\n");
  else
    printf("%02d (%s)\n", joy_data[i].mapped_x_8, joy_data[i].axes[joy_data[i].mapped_x_8].name);

  printf("  Mapped to Joystick  8-bit y-axis : ");
  if (joy_data[i].mapped_y_8 == NOT_MAPPED)
    printf("N/A\n");
  else
    printf("%02d (%s)\n", joy_data[i].mapped_y_8, joy_data[i].axes[joy_data[i].mapped_y_8].name);

  printf("  Mapped to Joystick 16-bit x-axis : ");
  if (joy_data[i].mapped_x_16 == NOT_MAPPED)
    printf("N/A\n");
  else
    printf("%02d (%s)\n", joy_data[i].mapped_x_16, joy_data[i].axes[joy_data[i].mapped_x_16].name);

  printf("  Mapped to Joystick 16-bit y-axis : ");
  if (joy_data[i].mapped_y_16 == NOT_MAPPED)
    printf("N/A\n");
  else
    printf("%02d (%s)\n", joy_data[i].mapped_y_16, joy_data[i].axes[joy_data[i].mapped_y_16].name);

  for (unsigned int j=0; j<ACORN_BUTTONS; j++) {
    if (joy_data[i].mapped_buttons[j] != NOT_MAPPED)
      printf("  Mapped to Joystick button %02d     : %02d\n", j, joy_data[i].mapped_buttons[j]);
  }

  if (adc_map.joy_id == i) {
    printf("  Mapped to ADC channel 0          : ");
    if (adc_map.channel0 == NOT_MAPPED)
      printf("N/A\n");
    else
      printf("%02d (%s)\n", adc_map.channel0, joy_data[i].axes[adc_map.channel0].name);

    printf("  Mapped to ADC channel 1          : ");
    if (adc_map.channel1 == NOT_MAPPED)
      printf("N/A\n");
    else
      printf("%02d (%s)\n", adc_map.channel1, joy_data[i].axes[adc_map.channel1].name);

    printf("  Mapped to ADC channel 2          : ");
    if (adc_map.channel2 == NOT_MAPPED)
      printf("N/A\n");
    else
      printf("%02d (%s)\n", adc_map.channel2, joy_data[i].axes[adc_map.channel2].name);

    printf("  Mapped to ADC channel 3          : ");
    if (adc_map.channel3 == NOT_MAPPED)
      printf("N/A\n");
    else
      printf("%02d (%s)\n", adc_map.channel3, joy_data[i].axes[adc_map.channel3].name);

    // todo: print out mapping for fire1 and fire2
  }

}





void debug_joystick(unsigned int i)
{
  printf("Joystick id %u (%s - %s)\n", i, joy_data[i].manufacturer, joy_data[i].product);

  printf("  Path                    : %s\n", joy_data[i].usb_path);
  printf("  File handle             : %u\n", joy_data[i].fp);

  printf("  Data stream open        : ");
  if (joy_data[i].open)
    printf("Yes\n");
  else
    printf("No (is something else using it?)\n");

  printf("  Local USB device name   : %s\n", joy_data[i].device_name);
  printf("  Interface               : %d\n", joy_data[i].interface);
  printf("  Endpoint                : %d\n", joy_data[i].endpoint);
  printf("  Device manufacturer     : %s\n", joy_data[i].manufacturer);
  printf("  Device product name     : %s\n", joy_data[i].product);
  printf("  Device serial number    : %s\n", joy_data[i].serial);
                                       
  printf("  USB vendor id           : 0x%04x\n", joy_data[i].vendor_id);
  printf("  USB product id          : 0x%04x\n", joy_data[i].product_id);
  printf("  USB device id           : 0x%04x\n", joy_data[i].device_id);

  printf("  Buffer handle           : %u\n", (unsigned int)(joy_data[i].buffer_handle));
  printf("  Buffer internal id      : %u\n", (unsigned int)(joy_data[i].buffer_internal_id));
  printf("  Buffer service routine  : 0x%08x\n", (unsigned int)(joy_data[i].buffer_service_routine));
  printf("  Buffer workspace        : 0x%08x\n", (unsigned int)(joy_data[i].buffer_workspace));

  printf("  DeviceFS handle         : 0x%08x\n", joy_data[i].devicefs_handle);
  printf("  Report data length      : %u\n", joy_data[i].report_length);

  printf("  Upcalls                 : %u (delta: %u)\n", joy_data[i].upcalls, joy_data[i].upcalls_delta);
  joy_data[i].upcalls_delta = 0;

  printf("  Good reads              : %u (delta: %u)\n", joy_data[i].good_reads, joy_data[i].good_reads_delta);
  joy_data[i].good_reads_delta = 0;

  printf("  Bad reads               : %u (delta: %u)\n", joy_data[i].bad_reads, joy_data[i].bad_reads_delta);
  joy_data[i].bad_reads_delta = 0;

  printf("  Raw report data         : ");
  for (int b=0; b<joy_data[i].report_length; b++) {
    printf("%02x ", joy_data[i].data_buf[b]);
  }
  printf("\n");

  printf("  Number of axes          : %d\n", joy_data[i].num_axes);
  printf("  Number of buttons       : %d\n", joy_data[i].num_buttons);
                                       
  printf("  HAT switch              : ");
  if (joy_data[i].hat_item)            
    printf("Yes\n");                   
  else                                 
    printf("No\n");                    
                                       
  printf("  DPAD                    : ");
  if (joy_data[i].has_dpad)            
    printf("Yes\n");
  else
    printf("No\n");

  printf("  Axes:\n");

  for (int a=0; a<joy_data[i].num_axes; a++) {
    printf("  Axis %02d %5s : ", a, joy_data[i].axes[a].name);
    printf("Slope 8 = %04.4f, ", joy_data[i].axes[a].acorn_slope_8);
    printf("Slope 16 = %04.4f, ", joy_data[i].axes[a].acorn_slope_16);
    printf("Slope ADC = %04.4f, ", joy_data[i].axes[a].adc_slope);
    printf("SP = %d:%d ", joy_data[i].axes[a].serial_port_lower_bound, joy_data[i].axes[a].serial_port_upper_bound);
    printf("Flip = ");
    if (joy_data[i].axes[a].flip)
      printf("on, ");
    else
      printf("off, ");
    struct hid_item *item = get_axis_item_by_type(i, joy_data[i].axes[a].type);
    if (item)
      printf("ReportId=%d", item->report_ID);
    else
      printf("(no item?)");
    printf("\n");
  }

  printf("  Button ReportIds : ");
  for (int a=0; a<JOY_BUTTONS; a++) {
    if (joy_data[i].button_items[a])
      printf("%02d=%d ", a, joy_data[i].button_items[a]->report_ID);
  }
  printf("\n");
}





struct hid_item *get_axis_item_by_type(unsigned int i, unsigned int type) {
  switch (type)
  {
    case AXIS_HATX:
    case AXIS_HATY:
      return joy_data[i].hat_item;

    case AXIS_DPADX:
      return joy_data[i].dpad_left_item;

    case AXIS_DPADY:
      return joy_data[i].dpad_up_item;

    default:
    {
      for (unsigned int a=0; a<JOY_USAGE_AXES; a++) {
        if (joy_data[i].axes_items[a]) {
          unsigned int a_usage = HID_USAGE(joy_data[i].axes_items[a]->usage);
          unsigned int a_type = supported_axes_usage[a_usage];
          if (a_type == type)
            return joy_data[i].axes_items[a];
        }
      }
      return NULL;
    }
  }
}





_kernel_oserror *command_handler(const char *args, int argc, int cmdno, void *pw)
{
  IGNORE(pw);

  switch (cmdno) {
    case CMD_USBJoystick_Read:
      return command_read(args, argc);

    case CMD_USBJoystick_EmulateAcorn:
      return command_emulate_acorn(args, argc);

    case CMD_USBJoystick_EmulateSerialPort:
      return command_emulate_serial_port(args, argc);

    case CMD_USBJoystick_EmulateJoy:
      return command_emulate_joy(args, argc);

    case CMD_USBJoystick_EmulateADC:
      return command_emulate_adc(args, argc);

    case CMD_USBJoystick_List:
      return command_list(args, argc);

    case CMD_USBJoystick_MapStick:
      return command_map_stick(args, argc);

    case CMD_USBJoystick_MapAxes8:
      return command_map_axes(args, argc, FALSE);

    case CMD_USBJoystick_MapAxes16:
      return command_map_axes(args, argc, TRUE);

    case CMD_USBJoystick_MapADC:
      return command_map_adc(args, argc);

    case CMD_USBJoystick_MapButtons:
      return command_map_buttons(args, argc);

    case CMD_USBJoystick_Flip:
      return command_flip(args, argc);

    case CMD_USBJoystick_Mapped:
      return command_mapped(args, argc);

    case CMD_USBJoystick_Debug:
      return command_debug(args, argc);

    default:
      printf("Unimplemented command!\n");
  }

  return NULL;
}




void servicecall_handler(int service_number, _kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);
  switch (service_number)
  {
    case Service_USBDriver:
      switch (r->r[0])
      {
        case Service_USBDriver_Attach:
          joy_check_device((const usb_service_t*)(r->r[2]), NULL);
          break;
      }
      break;

    case Service_DeviceDead:
      if (r->r[3] != 0)
        joy_remove_device((const char*)(r->r[3]));
      break;
  }
}




_kernel_oserror* swi_joystick_read(_kernel_swi_regs *r)
{
  char stick = r->r[0] & 0xFF;
  char reason = (r->r[0] & 0xFF00) >> 8;

  for (unsigned int i=0; i<JOY_MAX; i++) {
    if (joy_data[i].mapped_number == stick) {
      // found the stick, so return data in Acorn format
      if (reason == 1)
        joystick_read_acorn_16(r, i);
      else
        joystick_read_acorn_8(r, i);

      return NULL;
    }
  }

  //debug_printf("Acorn SWI: stick=%d, no map, returning default response\n", stick);

  if (reason == 1)
    r->r[1] = 0;   // for 16-bit api, this is 'no buttons pressed'
  r->r[0] = 0;     // default response: 8-bit: centered, no buttons pressed   16-bit: centered
  return NULL;
}





void joystick_read_acorn_8(_kernel_swi_regs *r, unsigned int i)
{
  // 8-bit Acorn API
  //   -127 is down/left and +127 is up/right (centered is 0)
  //   Vertical Twist recommend digital inputs (HAT) to be switched at +64 and -64

  if (joy_data[i].mapped_x_8 == NOT_MAPPED || joy_data[i].mapped_y_8 == NOT_MAPPED) {
    r->r[0] = 0;
    return;
  }

  struct axisdata_struct *ax = &(joy_data[i].axes[joy_data[i].mapped_x_8]);
  struct axisdata_struct *ay = &(joy_data[i].axes[joy_data[i].mapped_y_8]);

  int x = 0;

  if (ax->is_digital) {
    // HAT value of -1, 0 or +1 easily translates to -64, 0 or +64
    x = ax->val * ACORN_AXIS_HAT_SCALE_8;
  }
  else {
    x = ax->val - ax->min;
    x = (int) ((float)ACORN_AXIS_MIN_VALUE_8 + ax->acorn_slope_8 * (float)x);
  }

  if (ax->flip)
    x = x * -1;


  // For Y-axis, we *-1 so the lower value equates to down/bottom
  int y = 0;

  if (ay->is_digital) {
    // HAT value of -1, 0 or +1 easily translates to -64, 0 or +64
    y = ay->val * ACORN_AXIS_HAT_SCALE_8;
  }
  else {
    y = ay->val - ay->min;
    y = (int) ((float)ACORN_AXIS_MIN_VALUE_8 + ay->acorn_slope_8 * (float)y);
  }

  if (!(ay->flip))
    y = y * -1;

  unsigned int acorn = (y & 0xff) | ((x & 0xff) << 8);

  for (int b=0; b<ACORN_BUTTONS; b++) {
    if (joy_data[i].mapped_buttons[b] != NOT_MAPPED) {
        unsigned int bd = joy_data[i].buttons[joy_data[i].mapped_buttons[b]];
        acorn = acorn | (bd << (16+b));
      }
  }

  //if (acorn != 0)
    //debug_printf("Acorn SWI 8: i=%d   rawx=%d x=%d   rawy=%d y=%d --> result is %u\n", i, ax->val, x, ay->val, y, acorn);

  r->r[0] = acorn;
}





void joystick_read_acorn_16(_kernel_swi_regs *r, unsigned int i)
{
  // 16-bit Acorn API
  //   0 is down/left and 65535 is up/right (centered is 32768)
  //   Acorn advise using switch points of 12288 (down/left) and 53247 (up/right) for HAT

  if (joy_data[i].mapped_x_16 == NOT_MAPPED || joy_data[i].mapped_y_16 == NOT_MAPPED) {
    r->r[0] = 0;
    r->r[1] = 0;
    return;
  }
  
  struct axisdata_struct *ax = &(joy_data[i].axes[joy_data[i].mapped_x_16]);
  struct axisdata_struct *ay = &(joy_data[i].axes[joy_data[i].mapped_y_16]);

  int x = 0;

  if (ax->is_digital) {
    if (ax->val == ax->min)
      x = ACORN_AXIS_HAT_MIN_16;
    else if (ax->val == ax->max)
      x = ACORN_AXIS_HAT_MAX_16;
    else
      x = ACORN_AXIS_HAT_MID_16;
  }
  else {
    x = ax->val - ax->min;
    x = (int) ((float)ACORN_AXIS_MIN_VALUE_16 + ax->acorn_slope_16 * (float)x);
  }

  if (ax->flip)
    x = ACORN_AXIS_VALUES_16 - x;

  // For Y-axis, we invert so the lower value equates to down/bottom
  int y = 0;

  if (ay->is_digital) {
    if (ay->val == ay->min)
      y = ACORN_AXIS_HAT_MIN_16;
    else if (ay->val == ay->max)
      y = ACORN_AXIS_HAT_MAX_16;
    else
      y = ACORN_AXIS_HAT_MID_16;
  }
  else {
    y = ay->val - ay->min;
    y = (int) ((float)ACORN_AXIS_MIN_VALUE_16 + ay->acorn_slope_16 * (float)y);
  }

  if (!(ay->flip))
    y = ACORN_AXIS_VALUES_16 - y;

  unsigned int position = (y & 0xffff) | ((x & 0xffff) << 16);
  unsigned int buttons = 0;

  for (int b=0; b<ACORN_BUTTONS; b++) {
    if (joy_data[i].mapped_buttons[b] != NOT_MAPPED) {
        unsigned int bd = joy_data[i].buttons[joy_data[i].mapped_buttons[b]];
        buttons = buttons | (bd << b);
      }
  }

  //if (position != 0 || buttons != 0)
    //debug_printf("Acorn SWI 16: i=%u   rawx=%d, x=%d, xdig=%d   rawy=%d, y=%d, ydig=%d   -->   pos %u, buttons %u\n", i, ax->val, x, ax->is_digital, ay->val, y, ay->is_digital, position, buttons);

  r->r[0] = position;
  r->r[1] = buttons;
}





_kernel_oserror* swi_joystick_status(_kernel_swi_regs *r)
{
  unsigned int stick1 = 0;
  unsigned int stick2 = 0;

  for (unsigned int i=0; i<JOY_MAX; i++) {
    if (joy_data[i].mapped_number == 0) {
      stick1 = encode_stick_serial_port(i);
    }
    else if (joy_data[i].mapped_number == 1) {
      stick2 = encode_stick_serial_port(i);
    }
  }

  unsigned int sticks = (stick1 & 0xFF) | ((stick2 & 0xFF) << 8);
  //debug_printf("SerialPort SWI: stick1=%u, stick2=%u, both sticks=%u\n", stick1, stick2, sticks);
  r->r[0] = sticks;

  return NULL;
}




unsigned int encode_stick_serial_port(int i)
{
  if (joy_data[i].mapped_x_8 == NOT_MAPPED || joy_data[i].mapped_y_8 == NOT_MAPPED) {
    return 0;
  }
  
  struct axisdata_struct *ax = &(joy_data[i].axes[joy_data[i].mapped_x_8]);
  struct axisdata_struct *ay = &(joy_data[i].axes[joy_data[i].mapped_y_8]);

  int left = (ax->val < ax->serial_port_lower_bound);
  int right = (ax->val > ax->serial_port_upper_bound);

  if (ax->flip) {
    int temp = left;
    left = right;
    right = temp;
  }

  int up = (ay->val < ay->serial_port_lower_bound);
  int down = (ay->val > ay->serial_port_upper_bound);

  if (ay->flip) {
    int temp = up;
    up = down;
    down = temp;
  }

  // note: checks for any button
  int buttons = 0;
  for (int b=0; b<ACORN_BUTTONS; b++) {
    if (joy_data[i].mapped_buttons[b] != NOT_MAPPED) {
        unsigned int bd = joy_data[i].buttons[joy_data[i].mapped_buttons[b]];
        buttons = buttons | (bd << b);
      }
  }

  unsigned int anybutton = (buttons > 0);
  unsigned int sp = (right << 0) | (left << 1) | (down << 2) | (up << 3) | (anybutton << 4);
  //debug_printf("SerialPort SWI: id=%d, left=%d, right=%d, up=%d, down=%d, buttons=%d, anybutton=%d --> result %u\n", i, left, right, up, down, buttons, anybutton, sp);

  return sp;
}




_kernel_oserror* swi_joy_read(_kernel_swi_regs *r, int n)
{
  // n is 0 or 1 (stick)

  // return r0 = % FUDLR

  for (unsigned int i=0; i<JOY_MAX; i++) {
    if (joy_data[i].mapped_number == n) {
      r->r[0] = encode_stick_serial_port(i);
      return NULL;       // ok to leave early!
    }
  }

  return NULL;
}





_kernel_oserror* swi_joy_test(_kernel_swi_regs *r)
{
  // 255: nothing in Econet
  // 128: Econet present
  //   0: RTFM present

  r->r[0] = 0;

  return NULL;
}





_kernel_oserror* swi_joy_readpipe(_kernel_swi_regs *r)
{
  IGNORE(r);
  // don't know what to do here...
  return NULL;
}





_kernel_oserror* ukswiv_hook_handler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);

  // our pre-veneer has copied R11 (SWI number) to R9 so we can get at it
  // it also uses r9 as an output parameter to claim or pass-on the vector

  unsigned int swi_number = r->r[9];

  if (emulate_serial_port_on && swi_number == USBJoystickSerialPortSWI)
  {
    r->r[9] = 1; // claim (see pre-veneer)
    return swi_joystick_status(r);
  }
  else if (emulate_joy_on && swi_number == JoySWI_Read0)
  {
    r->r[9] = 1;
    return swi_joy_read(r, 0);
  }
  else if (emulate_joy_on && swi_number == JoySWI_Read1)
  {
    r->r[9] = 1;
    return swi_joy_read(r, 1);
  }
  else if (emulate_joy_on && swi_number == JoySWI_Test)
  {
    r->r[9] = 1;
    return swi_joy_test(r);
  }
  else if (emulate_joy_on && swi_number == JoySWI_ReadPipe)
  {
    r->r[9] = 1;
    return swi_joy_readpipe(r);
  }
  else
  {
    r->r[9] = 0; // pass-on (see pre-veneer)
    return NULL;
  }
}





int bytev_hook_handler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);

  // an application is trying to use osbyte to perform an I/O podule ADC conversion

  if (!emulate_adc_on)
    return VECTOR_PASSON;

  if (adc_map.joy_id == NOT_MAPPED)
    return VECTOR_PASSON;

  unsigned int value = 0;
  IGNORE(value);     // not used all the time!

  switch ((osbyte_op)(r->r[0]))
  {
    case osbyte_CHANNEL_COUNT:
    {
      // OSBYTE 16 - select how many channels are to be sampled
      adc_data.channels_to_be_sampled = r->r[1];
      return VECTOR_CLAIM;
    }

    case osbyte_CONVERT_CHANNEL:
    {
      // OSBYTE 17 - force ADC conversion (we just set current channel, no need to 'force')
      if (r->r[1] >= 1 && r->r[1] <= 4) {
        adc_data.current_channel = r->r[1];
        return VECTOR_CLAIM;
      }
    }

    case osbyte_BUFFER_OP:
    {
      // OSBYTE 128 - read ADC channel value and fire button status
      // BASIC's ADVAL() function uses this
      int value = 0;
      switch (r->r[1])
      {
        case osbyte_OP_JOYSTICK_STATE:
        {
          // hack: setting r2 to != 0 causes output of ADVAL(0) to be screwed up, so fix to 0
          r->r[1] = adc_read_fire();   // bits 0-1 should be button status
          r->r[2] = 0;                 // channel number last used for conversion (or 0=none)
          return VECTOR_CLAIM;
        }

        case osbyte_OP_CHANNEL_POSITION1:
        case osbyte_OP_CHANNEL_POSITION2:
        case osbyte_OP_CHANNEL_POSITION3:
        case osbyte_OP_CHANNEL_POSITION4:
        {
          value = adc_read_channel(r->r[1]);
          r->r[1] = (value & 0xFF) ;  // bits 0-7 should be low 8-bits
          r->r[2] = (value >> 8);     // bits 0-23 should be high 24 bits
          return VECTOR_CLAIM;
        }
      }
    }

    case osbyte_VAR_CURRENT_CHANNEL:
    {
      // OSBYTE 188 - read current ADC channel number
      r->r[1] = adc_data.current_channel;
      return VECTOR_CLAIM;
    }

    case osbyte_VAR_CHANNEL_COUNT:
    {
      // OSBYTE 189 - read maximum ADC channel number (as set by osbyte 16)
      r->r[1] = adc_data.channels_to_be_sampled;
      return VECTOR_CLAIM;
    }

    case osbyte_VAR_CONVERSION_RESOLUTION:
    {
      // OSBYTE 190 - read resolution of conversion: 12 (r0=0 or 12) or 8-bit (r0=8)
      r->r[1] = 12;
      return VECTOR_CLAIM;
    }

  }

  // bytev reason code/subcode was not for us
  return VECTOR_PASSON;
}





unsigned int adc_read_channel(unsigned int channel)
{
  unsigned int value = 0;
  int axis = NOT_MAPPED;

  switch (channel)
  {
    case 1:
    {
      axis = adc_map.channel0;
      break;
    }
    case 2:
    {
      axis = adc_map.channel1;
      break;
    }
    case 3:
    {
      axis = adc_map.channel2;
      break;
    }
    case 4:
    {
      axis = adc_map.channel3;
      break;
    }
  }

  if (axis == NOT_MAPPED)
    return value;

  struct axisdata_struct *a = &(joy_data[adc_map.joy_id].axes[axis]);

  if (a->is_digital) {
    if (a->val == a->min)
      value = ADC_AXIS_HAT_MIN;
    else if (a->val == a->max)
      value = ADC_AXIS_HAT_MAX;
    else
      value = ADC_AXIS_HAT_MID;
  }
  else {
    value = a->val - a->min;
    value = (int) ((float)ADC_AXIS_MIN_VALUE + a->adc_slope * (float)value);
  }

  if (a->flip)
    value = ADC_AXIS_VALUES - value;

  return value;
}





unsigned int adc_read_fire(void)
{
  unsigned int buttons = 0;

 if (adc_map.fire0 != NOT_MAPPED)
    buttons = buttons | joy_data[adc_map.joy_id].buttons[adc_map.fire0];

  if (adc_map.fire1 != NOT_MAPPED)
    buttons = buttons | (joy_data[adc_map.joy_id].buttons[adc_map.fire1] << 1);

  return (buttons & 0x3);
}






int upcallv_hook_handler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);

  // we only care about data received
  if (r->r[0] != UpCall_DeviceRxDataPresent) {
    return VECTOR_PASSON;
  }

  // temporary buffer for holding received data
  byte buffer[JOY_MAX_DATA_LENGTH];
  os_fw fp = (os_fw) (r->r[1]);

  // test our active sticks to see if this is one of ours
  for (unsigned int i=0; i<JOY_MAX; i++) {
    if (joy_data[i].fp == fp) {
      // this is the stick
      joy_data[i].upcalls++;
      joy_data[i].upcalls_delta++;

      // we need to read the bytes into a buffer
      unsigned int read = 0;
      unsigned int offset = joy_data[i].device->report_data_offset;
      unsigned int to_read = joy_data[i].report_length + offset;
      buffer_read(joy_data[i].buffer_internal_id, to_read, buffer, &read, joy_data[i].buffer_service_routine, joy_data[i].buffer_workspace);

      // if we have read the correct number of bytes, so copy to stick 'last known good data'
      if (read == to_read) {
        joy_data[i].good_reads++;
        joy_data[i].good_reads_delta++;
        memcpy(joy_data[i].data_buf, buffer, read);
        joystick_decode(i);
      }
      else {
        joy_data[i].bad_reads++;
        joy_data[i].bad_reads_delta++;
      }
      // can stop here, since this rx event cannot also be for another stick!
      // todo: is pass-on right?  should we return claim?
      return VECTOR_PASSON;
    }
  }

  // upcall was not for one of our sticks
  return VECTOR_PASSON;
}





_kernel_oserror* buffer_read(buffer_internal_id id, unsigned int to_read, byte *data, unsigned int *read, asm_routine code, void *ws)
{
  if (id == 0)
  {
    *read = 0;
    return NULL;
  }

  // find out the used space (buffer manager 6)
  unsigned int bufused = 0;
  __asm
  {
    MOV      R0,#buffer_SERVICE_USED_SPACE
    MOV      R1,id
    MOV      R12,ws
    BLX      code,{R0,R1,R12},{R2},{LR,PSR}
    MOV      bufused,R2
  }

  // max we can read is the size of the buffer
  if (to_read > bufused)
    to_read = bufused;

  // if the buffer is empty, bail
  if (to_read == 0)
  {
    *read = 0;
    return NULL;
  }

  // perform the read, then flush the buffer
  __asm
  {
    MOV      R0,#buffer_SERVICE_REMOVE_BLOCK
    MOV      R1,id
    MOV      R2,data
    MOV      R3,to_read
    MOV      R12,ws
    BLX      code,{R0-R3,R12},{},{R2,R3,LR,PSR}
    MOV      R0,#buffer_SERVICE_PURGE_BUFFER
    BLX      code,{R0,R1,R12},{},{LR,PSR}
  }

  // note how many bytes read from buffer
  *read = to_read;

  return NULL;
}
